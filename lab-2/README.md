# Лабораторная работа №2. Методы хвостовой рекурсии для обработки списков

## Задание

### Реализовать обработку списков с использованием механизма общей рекурсии.

## Задание №1

### Два множества представлены списками. Найти пересечение множеств.

```lisp
(defun search_element (a list)
	(cond
		;проверяем список на пустоту
		((null list) nil)
		;элемент принадлежит списку - вернуть T
		((eq a (car list)) t)
		;продолжаем проверку
		(t (search_element a (cdr list)))
	)
)

(defun intersection (a b)
	(cond
		;список a пуст
		((null a) nil)
		;список b пуст
		((null b) nil)
		;если голова a содержится в b, добавляем ее в ответ и продолжаем поиск
		((search_element (car a) b) (cons (car a) (intersection (cdr a) b)))
		;продолжаем поиск
		(t (intersection (cdr a) b))
	)
)

;примеры использования
(intersection '(2 3 1 8 11) '(1 2 3 7 11)) => (2 3 1 11)

(intersection '(2 4 5 3 1 8 11) '(1 2 3 7 11 4)) => (2 4 3 1 11)

(intersection '(1 2 3 4 5) '(4 3 1)) => (1 3 4)
```

## Задание №2

### Написать функцию, выполняющую над числовым одноуровневым списком следующую операцию:

```
(A B C ...) —> A^B^C...
```

**Причем последовательное возведение в степень выполняется справа налево.**

```lisp
;функция возведения числа в степень a^b
(defun pow (a b)
	(cond
		((= b 0) 1)
		(t (* a (pow a (- b 1))))
	)
)

(defun stairs (a)
	(cond
		;если список пустой => nil
		((null a) nil)
		;если один элемент => выведем этот элемент
		((null (cdr a)) (car a))
		;если остался 1 элемент, то возводим текущий элемент в степень
		((null (cddr a)) (pow (car a) (cadr a)))
		;возводим голову списка в степень
		(t (pow (car a) (stairs (cdr a))))
	)
)

;примеры использования
(stairs '(3)) => 3

(stairs '(3 0 2 4)) => 1

(stairs '(2 2 3)) => 256

(stairs '(2 1 3)) => 2
```